
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chess Engine</title>
  <link href="data:image/x-icon;base64,AAABAAEAEBACAAAAAACwAAAAFgAAACgAAAAQAAAAIAAAAAEAAQAAAAAAQAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAACQAAAAAAAAAAAAADwDwAA+B8AAPw/AADsNwAAzDMAAMQjAADkJwAA4AcAAPAPAAD4HwAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA" rel="icon" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Roboto', sans-serif; }
    .board, .info { width: 400px; margin: auto; }
    .move-history { height: auto; overflow-y: visible; }
    #loading-bar, #score { margin: 20px auto; text-align: center; font-size: 16px; }
    .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .clearfix-7da63 { clear: both; }
    .board-b72b1 { border: 2px solid #404040; -moz-box-sizing: content-box; box-sizing: content-box; }
    .square-55d63 { float: left; position: relative; user-select: none; }
    .white-1e1d7 { background-color: #f0d9b5; color: #b58863; }
    .black-3c85d { background-color: #b58863; color: #f0d9b5; }
    .highlight1-32417, .highlight2-9c5d2 { box-shadow: inset 0 0 3px 3px yellow; background-color: yellow; }
    .allowed-move { background-color: rgba(255, 255, 0, 0.5); }
    .notation-322f9 { cursor: default; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 14px; position: absolute; }
    .alpha-d2270 { bottom: 1px; right: 3px; }
    .numeric-fc462 { top: 2px; left: 2px; }
  </style>
  <script>
    window.console = window.console || function (t) {};
  </script>
  <base href="https://chessboardjs.com/" />
</head>
<body translate="no">
  <center>
    <br><h3 class="board">
      Chess Engine
    </h3>
    <div id="score">Rating: N/A</div>
    <div id="loading-bar">Welcome</div>
    <br>
    <div id="board" class="board"></div>
    <br>
  </center>
  <div class="info">
    <div id="move-history" class="move-history"></div>
  </div>
  <script src='https://code.jquery.com/jquery-2.2.4.min.js'></script>
  <script src='https://cdn.rawgit.com/lhartikk/simple-chess-ai/master/lib/js/chess.js'></script>
  <script src='https://chessboardjs.com/js/chessboard.js'></script>
  <script id="rendered-js">
    
	var board, game = new Chess();
    var lastComputerMove = null; 
    
	var pieceValues = {
	  'p': 100,
	  'n': 300,
	  'b': 300,
	  'r': 500,
	  'q': 900,
	  'k': 5000 
	};

	var centralControlValue = {
	  'e4': 10,
	  'd4': 10,
	  'e5': 10,
	  'd5': 10,
	  'c4': 5,
	  'f4': 5,
	  'c5': 5,
	  'f5': 5
	};

	var gamescomputed = 0
	let startTime, endTime;
	
    var calculateBestMove = function (game) {
		  var bestMove = null;
		  var bestValue = -Infinity;
		  
		  for (var move of game.ugly_moves()) {
			
			game.ugly_move(move);
			var boardValue = -minimax(game, 3, -Infinity, Infinity);
			game.undo();

			if (boardValue > bestValue) {
			  bestValue = boardValue;
			  bestMove = move;
			}
		  }
		  return bestMove;
		};

    var minimax = function (game, depth, alpha, beta) {
      if (depth === 0 || game.game_over()) {
        gamescomputed += 1
		return evaluateBoard(game);
      }

      var moves = game.ugly_moves();
      if (game.turn() === 'w') {
        let maxEval = -Infinity;
        for (var move of moves) {
          gamescomputed += 1
		  game.ugly_move(move);
          let eval = minimax(game, depth - 1, alpha, beta);
          game.undo();
          maxEval = Math.max(maxEval, eval);
          alpha = Math.max(alpha, eval);
          if (beta <= alpha) {
            break; 
          }
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (var move of moves) {
          gamescomputed += 1
		  game.ugly_move(move);
          let eval = minimax(game, depth - 1, alpha, beta);
          game.undo();
          minEval = Math.min(minEval, eval);
          beta = Math.min(beta, eval);
          if (beta <= alpha) {
            break; 
          }
        }
        return minEval;
      }
    };

    var evaluateBoard = function (game) {
	  var totalEvaluation = 0;
		
		if (game.game_over()) {
			if (game.in_checkmate()) {
			  if (game.turn() === 'w') {
					
					totalEvaluation += -1000000; 
				} else {
					
					totalEvaluation += 1000000; 
				} 
			}
			//if (game.in_stalemate()) {}
			
		}
		

		
	  for (var piece in pieceValues) {
		var pieceCount = game.board().reduce((count, row) => {
		  return count + row.reduce((count, square) => {
			return count + (square && square.type === piece ? (square.color === 'w' ? 1 : -1) : 0);
		  }, 0);
		}, 0);
		totalEvaluation += pieceCount * pieceValues[piece];


		var potentialLosses = game.ugly_moves().filter(move => {
		  const targetSquare = move.to;
		  return game.get(targetSquare) && game.get(targetSquare).color !== game.turn();
		});


		totalEvaluation -= potentialLosses.length * (pieceValues[piece] / 2); 
	  }

	  game.board().forEach((row, rowIndex) => {
		row.forEach((square, colIndex) => {
		  const squareName = String.fromCharCode(97 + colIndex) + (8 - rowIndex);
		  if (square && square.color === 'w') {
			totalEvaluation += centralControlValue[squareName] || 0; 
		  } else if (square && square.color === 'b') {
			totalEvaluation -= centralControlValue[squareName] || 0; 
		  }
		});
	  });
	  
	  const centerSquares = ['d4', 'd5', 'e4', 'e5'];
		centerSquares.forEach(squareName => {
			const squarePiece = game.get(squareName);
			if (squarePiece && squarePiece.color === 'w') {
				totalEvaluation += 20; 
			} else if (squarePiece && squarePiece.color === 'b') {
				totalEvaluation -= 20; 
			}
		});
	
		var whiteKingSquare, blackKingSquare;

		game.board().forEach((row, rowIndex) => {
			row.forEach((square, colIndex) => {
				if (square && square.type === 'k') { // 'k' for king
					if (square.color === 'w') {
						whiteKingSquare = String.fromCharCode(97 + colIndex) + (8 - rowIndex); // Convert to algebraic notation
					} else {
						blackKingSquare = String.fromCharCode(97 + colIndex) + (8 - rowIndex);
					}
				}
			});
		});
	
	
		if (whiteKingSquare) {
			const col = whiteKingSquare.charCodeAt(0) - 97; 
			if (game.get(whiteKingSquare + 8) && game.get(whiteKingSquare + 8).type === 'p' && game.get(whiteKingSquare + 8).color === 'w') {
				totalEvaluation += 50; 
			}
			if (game.get(whiteKingSquare - 8) && game.get(whiteKingSquare - 8).type === 'p' && game.get(whiteKingSquare - 8).color === 'w') {
				totalEvaluation += 50; 
			}
			if (game.get(whiteKingSquare - 7) && game.get(whiteKingSquare - 7).type === 'p' && game.get(whiteKingSquare - 7).color === 'w') {
				totalEvaluation += 30; 
			}
			if (game.get(whiteKingSquare + 7) && game.get(whiteKingSquare + 7).type === 'p' && game.get(whiteKingSquare + 7).color === 'w') {
				totalEvaluation += 30; 
			}
			
			totalEvaluation += (col === 3 || col === 4) ? 10 : 0; 
		}

		if (blackKingSquare) {
			const col = blackKingSquare.charCodeAt(0) - 97; 
			if (game.get(blackKingSquare + 8) && game.get(blackKingSquare + 8).type === 'p' && game.get(blackKingSquare + 8).color === 'b') {
				totalEvaluation -= 50; 
			}
			if (game.get(blackKingSquare - 8) && game.get(blackKingSquare - 8).type === 'p' && game.get(blackKingSquare - 8).color === 'b') {
				totalEvaluation -= 50; 
			}
			if (game.get(blackKingSquare - 7) && game.get(blackKingSquare - 7).type === 'p' && game.get(blackKingSquare - 7).color === 'b') {
				totalEvaluation -= 30; 
			}
			if (game.get(blackKingSquare + 7) && game.get(blackKingSquare + 7).type === 'p' && game.get(blackKingSquare + 7).color === 'b') {
				totalEvaluation -= 30; 
			}

			totalEvaluation -= (col === 3 || col === 4) ? 10 : 0; 
		}

	  updateScore(totalEvaluation);
	  return totalEvaluation;
	};

    var updateScore = function (score) {
      const maxScore = 1000; 
      const minScore = -1000; 
      let normalizedScore = Math.max(minScore, Math.min(maxScore, score)); 
      let whiteScore = ((normalizedScore + maxScore) / (2 * maxScore)) * 100; 
      let blackScore = ((maxScore - normalizedScore) / (2 * maxScore)) * 100; 
      const totalScore = whiteScore + blackScore;
      whiteScore = (whiteScore / totalScore) * 100;
      blackScore = (blackScore / totalScore) * 100;

      let scoreText;

      if (whiteScore > 50) {
        scoreText = `Advantage White: ${whiteScore.toFixed(0)}%`;
      } else if (blackScore > 50) {
        scoreText = `Advantage Black: ${blackScore.toFixed(0)}%`;
      } else {
        scoreText = `Even: White ${whiteScore.toFixed(0)}% | Black ${blackScore.toFixed(0)}%`;
      }

      $('#score').text(scoreText);
    };

    var onDragStart = function (source, piece, position, orientation) {
      if (game.in_checkmate() === true || game.in_draw() === true ||
        piece.search(/^b/) !== -1) {
        return false;
      }
    };

    var highlightAllowedMoves = function (piece) {
      const moves = game.moves({
        square: piece,
        verbose: true
      });

      for (let move of moves) {
        addAllowedMoveHighlight(move.to);
      }
    };

    var makeBestMove = function () {
		window.setTimeout(function () {
			var bestMove = calculateBestMove(game);
			game.ugly_move(bestMove);
			lastComputerMove = bestMove;
			board.position(game.fen());
			renderMoveHistory(game.history());
			updateScore(evaluateBoard(game));
			
			
			function formatNumber(num) {
				if (num < 1000) {
					return num.toString(); 
				} else if (num < 1000000) {
					return (num / 1000).toFixed(1) + 'k'; 
				} else if (num < 1000000000) {
					return (num / 1000000).toFixed(1) + 'm';
				} else {
					return (num / 1000000000).toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',') + 'b'; 
				}
			}
			
			endTime = Date.now();
			const elapsedTime = (endTime - startTime) / 1000;
			$('#loading-bar').text(formatNumber(gamescomputed) + ' moves analyzed in ' + elapsedTime.toFixed(1) + 's. Your turn!');
			
			if (game.game_over()) {
				let result = game.in_checkmate() ? (game.turn() === 'w' ? "Black won." : "White won.") : "Game drawn";
				$('#score').text("Game over.");
				$('#loading-bar').text(result);
			}
			
			
		}, 250);
	};

    var addAllowedMoveHighlight = function (square) {
      const squareEl = $('#board .square-' + square);
      squareEl.addClass('allowed-move');
      setTimeout(function () {
        squareEl.removeClass('allowed-move');
      }, 1000);
    };

    var greySquare = function (square) {
      const squareEl = $('#board .square-' + square);
      squareEl.addClass('highlight1-32417');
      setTimeout(function () {
        squareEl.removeClass('highlight1-32417');
      }, 1000);
    };

    var renderMoveHistory = function (moves) {
      var moveHistoryElement = $('#move-history');
      moveHistoryElement.empty();
      for (var i = 0; i < moves.length; i = i + 2) {
        moveHistoryElement.append('<span><b>' + (i/2 + 1) + '.</b> ' + moves[i] + ' ' + (moves[i + 1] ? moves[i + 1] : '') + '</span> ')
      }
      moveHistoryElement.scrollTop(moveHistoryElement[0].scrollHeight);
    };
	
    var onDrop = function (source, target) {
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q'
      });

      removeGreySquares();
      renderBoard();
      if (move === null) return; // illegal move

      renderMoveHistory(game.history());
	  updateScore(evaluateBoard(game));

      if (game.game_over()) {
			let result = game.in_checkmate() ? (game.turn() === 'w' ? "Black won." : "White won.") : "Game drawn";
			$('#score').text("Game over.");
			$('#loading-bar').text(result);
		} else {
			$('#loading-bar').text('Computer is thinking...') 
			gamescomputed = 0
			startTime = Date.now();
			makeBestMove();
		}
		updateScore(evaluateBoard(game));
    };

    var onSnapEnd = function () {
      renderBoard();
    };

    var onSquareClick = function (square) {
      
    };

    var onMouseoverSquare = function (square, piece) {
      var moves = game.moves({
        square: square,
        verbose: true
      });

      if (moves.length === 0) return;

      greySquare(square);
      for (var i = 0; i < moves.length; i++) {
        greySquare(moves[i].to);
      }
    };

    var onMouseoutSquare = function (square, piece) {
      removeGreySquares();
    };

    var removeGreySquares = function () {
      $('#board .square-55d63').css('background', '');
    };

    var greySquare = function (square) {
      var squareEl = $('#board .square-' + square);
      var background = '#a9a9a9';
      if (squareEl.hasClass('black-3c85d')) {
        background = '#696969';
      }
      squareEl.css('background', background);
    };

    var renderBoard = function () {
      board.position(game.fen());
    };

    var cfg = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onMouseoutSquare: onMouseoutSquare,
      onMouseoverSquare: onMouseoverSquare,
      onSnapEnd: onSnapEnd,
      onSquareClick: onSquareClick
    };
    board = ChessBoard('board', cfg);

    $('#loading-bar').text('Welcome.');
    board.position('start');


    $('#board').on('click', '.piece', function () {
      const pieceSquare = $(this).parent().data('square');
      highlightAllowedMoves(pieceSquare);
    });
	
  </script>
</body>
</html>
